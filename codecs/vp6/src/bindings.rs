// Much of this was copied from the (gigantic) bindings auto-generated by `bindgen`.

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
pub struct AVCodec {
    private: [u8; 0],
}
#[repr(C)]
pub struct AVFrame {
    private: [u8; 0],
}
#[repr(C)]
pub struct AVPacket {
    private: [u8; 0],
}
#[repr(C)]
pub struct AVCodecContext {
    private: [u8; 0],
}
#[repr(C)]
pub struct AVDictionary {
    private: [u8; 0],
}

pub const AV_INPUT_BUFFER_PADDING_SIZE: u64 = 8;

extern "C" {
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);

    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> ::std::os::raw::c_int;

    pub fn av_malloc(size: usize) -> *mut ::std::os::raw::c_void;

    pub fn av_packet_alloc() -> *mut AVPacket;
    pub fn av_packet_from_data(
        pkt: *mut AVPacket,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn av_packet_free(pkt: *mut *mut AVPacket);

    pub fn av_frame_alloc() -> *mut AVFrame;
    pub fn av_frame_free(frame: *mut *mut AVFrame);

    pub fn avcodec_send_packet(
        avctx: *mut AVCodecContext,
        avpkt: *const AVPacket,
    ) -> ::std::os::raw::c_int;
    pub fn avcodec_receive_frame(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
    ) -> ::std::os::raw::c_int;

}

// These are our own helpers
extern "C" {
    pub static mut ff_vp6f_decoder_ptr: *mut AVCodec;


    pub fn frame_width(arg1: *mut AVFrame) -> ::std::os::raw::c_int;
    pub fn frame_height(arg1: *mut AVFrame) -> ::std::os::raw::c_int;
    pub fn frame_data(
        arg1: *mut AVFrame,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_uchar;
    pub fn frame_linesize(arg1: *mut AVFrame, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}



use std::marker::Sized;
use std::mem::size_of;
use std::alloc::{
    Layout,
    alloc as underlying_alloc,
    dealloc as underlying_dealloc,
};

unsafe fn wrapped_alloc(size : u32) -> *mut u8 {
    // Compute a layout sufficient to store `AllocInfo`
    // immediately before it.
    let modified_layout = Layout::from_size_align(size as usize + 4, 4).unwrap();

    let orig_ptr = underlying_alloc(modified_layout);
    if orig_ptr.is_null() {
        return orig_ptr;
    }

    let result_ptr = orig_ptr.add(4);

    (orig_ptr.add(4) as *mut u32).write_unaligned(size);

    result_ptr
}

unsafe fn wrapped_dealloc(ptr: *mut u8) {
    assert!(!ptr.is_null());
    let info_ptr = ptr.sub(4);
    let size = (info_ptr as *mut u32).read_unaligned();
    underlying_dealloc(ptr, Layout::from_size_align(size as usize, 4).unwrap());
}



#[cfg(target_arch = "wasm32")]
#[no_mangle]
fn malloc(bytes: usize) -> *mut u8 {
    unsafe {
        wrapped_alloc(bytes as u32)
    }
}

#[cfg(target_arch = "wasm32")]
#[no_mangle]
fn realloc(ptr: *mut u8, bytes: usize) -> *mut u8 {
    unsafe {
        if ptr.is_null() {
            return malloc(bytes);
        }

        let info_ptr = ptr.sub(4);
        let size = (info_ptr as *mut u32).read_unaligned();

        let new_ptr = malloc(bytes);

        for i in 0..bytes.min(size as usize) {
            new_ptr.add(i).write_unaligned(ptr.add(i).read_unaligned());
        }

        new_ptr
    }
}

#[cfg(target_arch = "wasm32")]
#[no_mangle]
fn free(ptr: *mut u8) {
    unsafe {
        if !ptr.is_null() {
            //wrapped_dealloc(ptr)
        }
    }
}
